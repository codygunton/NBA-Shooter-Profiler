#+TODO: TODO | RUN
* RUN Imports

See eda.orgjupypy for more basic descriptions the data.
#+begin_src jupyter-python
import pandas as pd
import numpy as np

df = pd.read_csv("../data/shot_logs.csv")
#+end_src

#+RESULTS:

* Clean data
** RUN Restrict vars and inspect

We will try understand how a shooter's shot selection, described in terms of a restricted set of variables, is a good predictor of a win or loss for the team. We expect that this can only be the case for players that are one of the most important players on their team.
#+begin_src jupyter-python :results none
keep_vars = ["GAME_ID", "W", "SHOT_CLOCK", 
             "GAME_CLOCK", "DRIBBLES", "TOUCH_TIME", 
             "SHOT_DIST", "player_name"]
cluster_vars = ["SHOT_CLOCK", 
                "DRIBBLES", 
                "TOUCH_TIME", 
                "SHOT_DIST"]
df = df[keep_vars]
#+end_src

We check to see which columns contain a missing value.
#+begin_src jupyter-python
print(df.isna().any())
#+end_src

#+RESULTS:
: GAME_ID        False
: W              False
: SHOT_CLOCK      True
: GAME_CLOCK     False
: DRIBBLES       False
: TOUCH_TIME     False
: SHOT_DIST      False
: player_name    False
: dtype: bool

There are missing values of SHOT_CLOCK, and not of any other variable. These come both from the clock being turned off at the time of the shot (this is resolvable by using the game clock at the time) and from the values simply being missing (I have often seen shot clocks malfunction while watching a game).

How prevalent is this problem?
#+begin_src jupyter-python
df_na = df[df.SHOT_CLOCK.isna()] # frame of rows from df with missing SHOT_CLOCK value
num_na = df_na.shape[0]
print(f"There are {num_na} rows out of 128069", 
      f"({np.round(100*num_na/df.shape[0], 1)}%)", 
      "with a missing value of SHOT_CLOCK.")
#+end_src

#+RESULTS:
: There are 5567 rows out of 128069 (4.3%) with a missing value of SHOT_CLOCK.


Here is a basic description of the variables we intend to use for clustering:
#+begin_src jupyter-python
print(df[cluster_vars].describe())
#+end_src

#+RESULTS:
:           SHOT_CLOCK       DRIBBLES     TOUCH_TIME      SHOT_DIST
: count  122502.000000  128069.000000  128069.000000  128069.000000
: mean       12.453344       2.023355       2.765901      13.571504
: std         5.763265       3.477760       3.043682       8.888964
: min         0.000000       0.000000    -163.600000       0.000000
: 25%         8.200000       0.000000       0.900000       4.700000
: 50%        12.300000       1.000000       1.600000      13.700000
: 75%        16.675000       2.000000       3.700000      22.500000
: max        24.000000      32.000000      24.900000      47.200000

Everything seems to be in order except for some missing SHOT_CLOCK values and the existence of some negative values of TOUCH_TIME. How many such values exist?
#+begin_src jupyter-python
df_neg = df[df.TOUCH_TIME<0]
print("The number of negative negative TOUCH_TIME",
      f"values is {df_neg.shape[0]}.")
df_neg.nunique()
#+end_src

#+RESULTS:
:RESULTS:
: The number of negative negative TOUCH_TIME values is 312.
: GAME_ID        249
: W                2
: SHOT_CLOCK     148
: GAME_CLOCK     257
: DRIBBLES         2
: TOUCH_TIME      72
: SHOT_DIST      164
: player_name    163
: dtype: int64
:END:

We see that the problem of negative touch times is prevalent: it occurs in 249/904 games, in a variety of SHOT_CLOCK/GAME_CLOCK settings. However, it only occurs for two values of DRIBBLES:
#+begin_src jupyter-python
df_neg.DRIBBLES.value_counts()
#+end_src

#+RESULTS:
: 0    311
: 2      1
: Name: DRIBBLES, dtype: int64

** Missing shot clock values
*** RUN Replace GAME_CLOCK column
What does GAME_CLOCK look like when SHOT_CLOCK is nan? Values of the variable GAME_CLOCK are times in the form mm:ss. We convert those times to seconds.
#+begin_src jupyter-python :results none
def mmss_to_sec(s):  # is a series who entires are strings of times of the form "mm:ss"
    ddf = s.str.split(":", expand=True)
    ddf = ddf.astype(int)
    return ddf[0]*60 + ddf[1]
df = df.assign(GAME_CLOCK=mmss_to_sec(df.GAME_CLOCK))
df_na = df_na.assign(GAME_CLOCK=mmss_to_sec(df_na.GAME_CLOCK))
#+end_src


I treat those missing values with GAME_CLOCK <= 24 as uncontroversial with regard to how they should be imputed. In such cases, the shot clock is turned off. I'll fill those by using the game clock value. The remaining values are controversial:
#+begin_src jupyter-python
contro = df_na[df_na.GAME_CLOCK>24]
print(f"There are {contro.shape[0]} controversial rows.")
contro.nunique()
#+end_src

#+RESULTS:
:RESULTS:
: There are 2013 controversial rows.
: GAME_ID         35
: W                2
: SHOT_CLOCK       0
: GAME_CLOCK     655
: DRIBBLES        25
: TOUCH_TIME     139
: SHOT_DIST      285
: player_name    175
: dtype: int64
:END:

*** Analysis of controversial shots
How many controversial shots are there in each game?
#+begin_src jupyter-python
vcs = pd.DataFrame(contro.GAME_ID.value_counts())
vcs = vcs.rename(columns={"GAME_ID":"# missing"})
vcs.index.name = "GAME_ID"
print(vcs)
#+end_src

#+RESULTS:
#+begin_example
          # missing
GAME_ID            
21400339        169
21400579        149
21400115        141
21400616        138
21400648        135
21400032        133
21400084        129
21400675        121
21400088        118
21400300         84
21400494         72
21400562         72
21400815         71
21400787         69
21400667         69
21400548         68
21400680         68
21400868         62
21400538         40
21400449         31
21400169         18
21400692         12
21400813         10
21400814         10
21400741          6
21400086          5
21400907          5
21400159          1
21400344          1
21400400          1
21400625          1
21400066          1
21400761          1
21400031          1
21400001          1
#+end_example


In the worst case, Game 21400339, almost all of the shots have a missing SHOT_CLOCK value:
#+begin_src jupyter-python
bad_ID = 21400339
num_total = df[df.GAME_ID==bad_ID].shape[0]
num_missing = contro[contro.GAME_ID==bad_ID].shape[0]
print(f"In game {bad_ID}, {num_missing} shots", 
      f"out of {num_total} have a missing value",
      "of SHOT_CLOCK.")
#+end_src

#+RESULTS:
: In game 21400339, 169 shots out of 179 have a missing value of SHOT_CLOCK.

What about a game with only a few controversial rows?
#+begin_src jupyter-python
contro[contro.GAME_ID == 21400741]
#+end_src

#+RESULTS:
:RESULTS:
|       | GAME_ID  | W | SHOT_CLOCK | GAME_CLOCK | DRIBBLES | TOUCH_TIME | SHOT_DIST | player_name        |
|-------+----------+---+------------+------------+----------+------------+-----------+--------------------|
| 13859 | 21400741 | W | NaN        | 594        | 2        | 2.1        | 6.8       | leandro barbosa    |
| 16053 | 21400741 | W | NaN        | 593        | 0        | 0.0        | 3.2       | marreese speights  |
| 16056 | 21400741 | W | NaN        | 373        | 0        | 0.0        | 2.6       | marreese speights  |
| 17067 | 21400741 | W | NaN        | 458        | 0        | 1.1        | 24.2      | andre iguodala     |
| 37940 | 21400741 | L | NaN        | 570        | 0        | 0.8        | 25.5      | charlie villanueva |
| 38437 | 21400741 | L | NaN        | 383        | 1        | 2.9        | 2.2       | chandler parsons   |
:END:


Among these, we see that some have short touch time, or few dribbles, or short distance. This suggests that some were shot before the shot clock reset.
#+begin_src jupyter-python
num_contro = contro.shape[0]
num_short = contro[(contro.TOUCH_TIME<4)].shape[0]
print(f"{num_short} out of {num_contro} outstanding",
      f"shots have a touch time of <4 seconds.")
#+end_src

#+RESULTS:
: 1591 out of 2013 outstanding shots have a touch time of <4 seconds.

We conclude ~75% of the controversial values have a short touch time, suggesting a missed shot clock reset.

*** Less conservative policy: 
- Drop those games with > _10? 20?_ contraversial rows. For the rest: 
  - If GAME_CLOCK =< 24: fill SHOT_CLOCK using GAME_CLOCK;
  - If DRIBBLES < _5?_: assume the clock didn't reset, 
    and set SHOT_CLOCK = 24 - TOUCH_TIME.
Note: the last part of this is a bad polciy in more recent seasons, when the shot clock would only reset to 14 after an offensive rebound.
*** Most conservative policy
- Drop all 35 games with a controversial value.

The benefit of this policy is that it would allows us to conduct a game-by-game analysis for each player. We don't do this in our shot profiling application, so we opt not to use this policy since it would drop a large number of useful datapoints:
#+begin_src jupyter-python
num_shots = sum(df.GAME_ID.isin(contro.GAME_ID.unique()))
print(f"This policy would drop {num_shots} shots.")
#+end_src

#+RESULTS:
: This policy would drop 5110 shots.
*** RUN Our policy:
 We will follow this policy for resolving missing SHOT_CLOCK values:
 - Drop controversial rows.
 - For the remaining rows, GAME_CLOCK =< 24. For these, fill SHOT_CLOCK using GAME_CLOCK.

 #+begin_src jupyter-python
 df = df.drop(contro.index)
 GC_vals = df[df.SHOT_CLOCK.isna()].GAME_CLOCK.unique()
 print("For the remaining missing values," 
       f"the game clock is <= {GC_vals.max()}")
 #+end_src

 #+RESULTS:
 : For the remaining missing values,the game clock is <= 24

 We now fill the remaining missing values with 0:
 #+begin_src jupyter-python
 new_SHOT_CLOCK = df.SHOT_CLOCK.fillna(df.GAME_CLOCK)
 df = df.assign(SHOT_CLOCK = new_SHOT_CLOCK)
 #+end_src

 #+RESULTS:

 We check each column to verify that there are no missing values:
 #+begin_src jupyter-python
 print(df.isna().any())
 #+end_src

 #+RESULTS:
 : GAME_ID        False
 : W              False
 : SHOT_CLOCK     False
 : GAME_CLOCK     False
 : DRIBBLES       False
 : TOUCH_TIME     False
 : SHOT_DIST      False
 : player_name    False
 : dtype: bool

** RUN Clip touch times

#+begin_src jupyter-python
print(f"There are {sum(df.TOUCH_TIME==0)} shots with TOUCH_TIME==0.")
#+end_src

#+RESULTS:
: There are 2985 shots with TOUCH_TIME==0.

We saw before that all but one of the shots with negative touch time was preceded by zero dribbles (like a catch-and-shoot or tip-in situation). Since TOUCH_TIME==0 occurs naturally in the dataset, it is natural to clip negative touch times from below to 0 whenever those shots were preceded by zero dribbles. This leaves only one outstanding row:
#+begin_src jupyter-python
df[(df.TOUCH_TIME<0)&(df.DRIBBLES>0)].iloc[0]
#+end_src

#+RESULTS:
: GAME_ID            21400821
: W                         W
: SHOT_CLOCK               23
: GAME_CLOCK              337
: DRIBBLES                  2
: TOUCH_TIME             -0.1
: SHOT_DIST              24.2
: player_name    kyrie irving
: Name: 44723, dtype: object

The one shot with two dribbles looks like a touch time of 1 second--the shot clock was at 23. Hence we can reasonably set all of these touch times to zero, or possibly set the exceptional shot's touch time to 1 second. I'll just set them all to 0:
#+begin_src jupyter-python
masked_TOUCH_TIME = df.TOUCH_TIME.mask(df.TOUCH_TIME<0, 0)
df = df.assign(TOUCH_TIME=masked_TOUCH_TIME)
#+end_src

#+RESULTS:

* output data frame

#+begin_src jupyter-python
print(f"Exporting a dataframe of shape {df.shape} to csv.")
df.to_csv("../data/shot_logs_prepped.csv", index=False)
#+end_src

#+RESULTS:
: Exporting a dataframe of shape (126056, 8) to csv.

* Summary of cleaning

- We kept the variables:
    ["GAME_ID", "W", "SHOT_CLOCK", 
     "GAME_CLOCK", "DRIBBLES", "TOUCH_TIME", 
     "SHOT_DIST", "player_name"]

- We converted GAME_CLOCK from strings to ints (unit: seconds).

- We filled handled missing SHOT_CLOCK values by:
  - Replacing SHOT_CLOCK by GAME_CLOCK whenever GAME_CLOCK<=24.
  - Dropping the remaining rows (2013/128069; 1.6% of the data) .

- We clipped negative touch times to 0.
