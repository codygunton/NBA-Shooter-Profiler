* Imports and basic notes
#+begin_src jupyter-python :results none
import re
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from numpy import vectorize as vec
from sklearn.cluster import KMeans
import seaborn as sns
import pandas as pd
from timeit import default_timer as timer

# pd.options.mode.chained_assignment = None
df = pd.read_csv("./shot_logs.csv")
#+end_src

The data comes sorted by player name. 
The GAME_ID is formated in one of two ways, depending ont the value of LOCATION:
  - AWAY @ HOME if the game was a home game for the player (i.e., LOCATION=H)
  - HOME vs. AWAY if the game was an away game for the player (i.e., LOCATION=A)
Therefore, the players team is always listed first.

The teams had played between 59 and 62 games, played between
2014-10-28 and 2015-03-04. (see below)

** how many games did each team play?

Get team abbreviations.
#+begin_src jupyter-python :display none
team_abbrevs = df.MATCHUP.apply(lambda s: s[-3:]).unique()
#+end_src

#+RESULTS:

Make a data frame for each game.
#+begin_src jupyter-python
# it's safe to assume that the away team takes a shot in every game,
# so, add columns for HOME_TEAM and AWAY_TEAM, we can just look at entries
# LOCATION = A, i.e., look at shots taken by players from the away team.

ddf = df[df.LOCATION=="A"]
ddf = ddf.assign(AWAY_TEAM=lambda ddf: ddf.MATCHUP.apply(lambda s: s[-9:-6]))
ddf = ddf.assign(HOME_TEAM=lambda ddf: ddf.MATCHUP.apply(lambda s: s[-3:]))
ddf = ddf[["GAME_ID", "AWAY_TEAM", "HOME_TEAM"]].drop_duplicates()
print(ddf.shape)
print(df.GAME_ID.nunique())
#+end_src

#+RESULTS:
: (904, 3)
: 904

Many games are missing. There should be 82*30/2 = 1230 games.

How many did each team play?
#+begin_src jupyter-python
# count games played by a given team with abbreviation ab
num_games = np.vectorize(lambda ab: ddf[(ddf.HOME_TEAM == ab) | (ddf.AWAY_TEAM == ab)].shape[0])
pd.DataFrame({"games_played": num_games(team_abbrevs)}, index=team_abbrevs).T
#+end_src

#+RESULTS:
:RESULTS:
|              | BKN | LAL | ORL | BOS | CHI | DAL | OKC | DET | IND | PHI | ... | MIL | UTA | PHX | MEM | ATL | GSW | POR | LAC | SAC | CHA |
|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|
| games_played | 59  | 60  | 62  | 59  | 61  | 62  | 61  | 60  | 60  | 61  | ... | 60  | 60  | 62  | 60  | 60  | 59  | 59  | 62  | 59  | 59  |

1 rows × 30 columns
:END:


Finding the dates of the games played.
#+begin_src jupyter-python
rgx = re.compile("^(.*\d{1})") # capture date part of the values of MATCHUP.
dates = df.MATCHUP.apply(lambda s: re.match(rgx, s).group(1)).drop_duplicates()
dates = pd.to_datetime(dates).to_frame() # sort and produce frame.
dates.sort_values(by="MATCHUP")
#+end_src

#+RESULTS:
:RESULTS:
|      | MATCHUP    |
|------+------------|
| 9282 | 2014-10-28 |
| 368  | 2014-10-29 |
| 5457 | 2014-10-30 |
| 9267 | 2014-10-31 |
| 364  | 2014-11-01 |
| ...  | ...        |
| 1671 | 2015-02-28 |
| 13   | 2015-03-01 |
| 1654 | 2015-03-02 |
| 9    | 2015-03-03 |
| 0    | 2015-03-04 |

120 rows × 1 columns
:END:

** player names 

The names are lower case, which is annoying when making legends etc., and they got Joe Ingles's name wrong.
#+begin_src jupyter-python
df.player_name = df.player_name.apply(lambda s: s.title())

def jon_to_joe(name):
    if name == "Jon Ingles":
        return "Joe Ingles"
    else:
        return name
df.player_name = df.player_name.apply(jon_to_joe)

df[df.player_name == "Joe Ingles"]
#+end_src

#+RESULTS:
:RESULTS:
|      | GAME_ID  | MATCHUP                    | LOCATION | W   | FINAL_MARGIN | SHOT_NUMBER | PERIOD | GAME_CLOCK | SHOT_CLOCK | DRIBBLES | ... | SHOT_DIST | PTS_TYPE | SHOT_RESULT | CLOSEST_DEFENDER   | CLOSEST_DEFENDER_PLAYER_ID | CLOSE_DEF_DIST | FGM | PTS | player_name | player_id |
|------+----------+----------------------------+----------+-----+--------------+-------------+--------+------------+------------+----------+-----+-----------+----------+-------------+--------------------+----------------------------+----------------+-----+-----+-------------+-----------|
| 7405 | 21400898 | MAR 04, 2015 - UTA @ BOS   | A        | L   | -1           | 1           | 1      | 10:26      | 11.3       | 0        | ... | 25.2      | 3        | missed      | Smart, Marcus      | 203935                     | 5.8            | 0   | 0   | Joe Ingles  | 204060    |
| 7406 | 21400898 | MAR 04, 2015 - UTA @ BOS   | A        | L   | -1           | 2           | 1      | 3:46       | 6.4        | 6        | ... | 26.6      | 3        | missed      | Turner, Evan       | 202323                     | 6.6            | 0   | 0   | Joe Ingles  | 204060    |
| 7407 | 21400898 | MAR 04, 2015 - UTA @ BOS   | A        | L   | -1           | 3           | 2      | 5:46       | 2.1        | 0        | ... | 26.1      | 3        | missed      | Young, James       | 203923                     | 5.2            | 0   | 0   | Joe Ingles  | 204060    |
| 7408 | 21400898 | MAR 04, 2015 - UTA @ BOS   | A        | L   | -1           | 4           | 3      | 9:35       | 5.5        | 2        | ... | 4.5       | 2        | made        | Crowder, Jae       | 203109                     | 2.3            | 1   | 2   | Joe Ingles  | 204060    |
| 7409 | 21400898 | MAR 04, 2015 - UTA @ BOS   | A        | L   | -1           | 5           | 3      | 8:29       | 6.9        | 2        | ... | 5.1       | 2        | missed      | Zeller, Tyler      | 203092                     | 1.4            | 0   | 0   | Joe Ingles  | 204060    |
| ...  | ...      | ...                        | ...      | ... | ...          | ...         | ...    | ...        | ...        | ...      | ... | ...       | ...      | ...         | ...                | ...                        | ...            | ... | ... | ...         | ...       |
| 7620 | 21400037 | NOV 01, 2014 - UTA vs. PHX | H        | W   | 27           | 2           | 3      | 0:50       | 8.7        | 2        | ... | 25.5      | 3        | missed      | Morris, Marcus     | 202694                     | 5.3            | 0   | 0   | Joe Ingles  | 204060    |
| 7621 | 21400037 | NOV 01, 2014 - UTA vs. PHX | H        | W   | 27           | 3           | 4      | 8:37       | 15.6       | 0        | ... | 24.7      | 3        | missed      | Morris, Markieff   | 202693                     | 6.5            | 0   | 0   | Joe Ingles  | 204060    |
| 7622 | 21400019 | OCT 30, 2014 - UTA @ DAL   | A        | L   | -18          | 1           | 4      | 11:30      | 8.5        | 0        | ... | 23.1      | 2        | made        | Jefferson, Richard | 2210                       | 6.5            | 1   | 2   | Joe Ingles  | 204060    |
| 7623 | 21400019 | OCT 30, 2014 - UTA @ DAL   | A        | L   | -18          | 2           | 4      | 11:30      | 8.5        | 0        | ... | 23.1      | 2        | made        | Jefferson, Richard | 2210                       | 6.5            | 1   | 2   | Joe Ingles  | 204060    |
| 7624 | 21400012 | OCT 29, 2014 - UTA vs. HOU | H        | L   | -11          | 1           | 2      | 7:53       | 9.3        | 0        | ... | 22.4      | 3        | missed      | Ariza, Trevor      | 2772                       | 11.6           | 0   | 0   | Joe Ingles  | 204060    |

220 rows × 21 columns
:END:

** correlations

#+begin_src jupyter-python :file correlations-heatmap.png
sns.heatmap(df.corr(), cmap="YlGnBu")
# hm.get_figure().savefig("./correlations_heatmap.png")
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.axes._subplots.AxesSubplot at 0x7f3d7e7f70d0>
[[file:correlations-heatmap.png]]
:END:

There are three pairs of highly-correlated variables and a couple
weaker but possibly significant other pairs

Look for a particular player in a particular circumstance. For players
near the basket (at least), it can happen that DRIBBLES and TOUCH_TIME
are less strongly correlated. E.g., Anthony Davis in losses, Tyson
Chandler in wins.



#+begin_src jupyter-python :file curry-correlations-heatmap.png
pname = "Stephen Curry"
sns.heatmap(df[(df.player_name==pname)
#               &(df.W=="W")
].corr(), cmap="YlGnBu")
# hm.get_figure().savefig("./correlations_heatmap.png")
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.axes._subplots.AxesSubplot at 0x7f3d7acb0d90>
[[file:curry-correlations-heatmap.png]]
:END:

* Dribbles before shots
** matplotlib
Number of shots vs number of dribbles, unnormalized.
#+begin_src jupyter-python :file steph-klay-pyplot.png
players = ["Klay Thompson", "Stephen Curry"]
L = list(map(lambda s: df[df.player_name==s].DRIBBLES, players))
fig, ax = plt.subplots()
plt.hist(L, bins=24, label = players)
plt.legend(players)
fig.set_facecolor("white")
fig.set_dpi(150)
#+end_src

#+RESULTS:
[[file:steph-klay-pyplot.png]]

** seaborn
*** set up seaborn

See [[https://matplotlib.org/tutorials/introductory/customizing.html][sample matplotlibrc]] and [[https://matplotlib.org/3.2.1/_modules/matplotlib/rcsetup.html][matplotlib.rcsetup]] for available customizations.
 [[https://stackoverflow.com/questions/55767312/how-to-position-suptitle][this SO post]] is useful for understanding positioning, specifically for suptitles.
To see which fonts lie ini the font.serif family:
    from matplotlib import rcParams
    rcParams['font.serif']
This would return 
| DejaVu Serif | Bitstream Vera Serif | Computer Modern Roman | New Century Schoolbook | Century Schoolbook L | Utopia | ITC Bookman | Bookman | Nimbus Roman No9 L | Times New Roman | Times | Palatino | Charter | serif |
To list all install ttf fonts:
    from matplotlib import font_manager
    font_manager.findSystemFonts(fontext='ttf')
Looking from there / running the little program called ""waterfall"", 
I guess names (must be a better way...). Some of them:
    DejaVu Serif, Cantarell, Liberation Serif (=Tinos?), Cousine, Source Serif/etc Pro/Variable/etc, Hack, Nimbus Roman, Z003, P052, C059

#+begin_src jupyter-python :results none
sns.set(context="notebook",
  rc={"font.size":12, "font.family":"sans-serif", 
      "font.serif":"P052", # note: kills the original list font.serif
      "axes.titlesize":"large", "axes.titlepad":20, 
      "axes.titleweight":"bold",
      "axes.labelsize":"medium", "axes.labelpad":10, 
      "axes.labelweight":"light",  # lighter is not actually an option
      "xtick.labelsize":"small", "ytick.labelsize":"small", 
#      "axes.facecolor":"white", # vertical axis padding is werid with this
      "legend.fontsize": "medium",
      "xtick.major.width":3, "ytick.major.width":3,
      "legend.loc":"best",
      "figure.dpi":50
  }
)

context: "notebook"
#+end_src

*** specify players
#+begin_src jupyter-python :results none
players = ["James Harden", "Joe Ingles"]
#+end_src
*** overlapping plots
**** unnormalized
#+begin_src jupyter-python :file harden-ingles-overlap.png
fig, ax = plt.subplots()

list(map(lambda s: 
         sns.distplot(df[df.player_name==s].DRIBBLES, 
                      bins=range(31), kde=False, label=s), 
         players)
)

plt.xlabel('dribbles')
plt.ylabel('shots')
plt.legend()
plt.title("Number of shots taken after a number of dribbles")
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 1.0, 'Number of shots taken after a number of dribbles')
[[file:harden-ingles-overlap.png]]
:END:

**** normalized
#+begin_src jupyter-python :file harden-ingles-overlap-normalized.png
fig, ax = plt.subplots()

list(map(lambda s: 
         sns.distplot(df[df.player_name==s].DRIBBLES, 
                      bins=range(31), kde=False, label=s, norm_hist=True), 
         players)
)

plt.xlabel('dribbles')
plt.ylabel('%')
plt.legend()
plt.title('Percentage of shots taken after a given number of dribbles')
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 1.0, 'Percentage of shots taken after a given number of dribbles')
[[file:harden-ingles-overlap-normalized.png]]
:END:

*** side-by-side
**** build value_counts data frame
Now I am going to make side-by-side bar plots using seaborn cat plot.

First I have to make the relevant dataframe.
#+begin_src jupyter-python
ddf = df[df.player_name.isin(players)]
ser = ddf.groupby("player_name").DRIBBLES
ser = ser.value_counts().sort_index()
ddf = ser.to_frame()
ddf.columns = ["SHOTS"]
ddf = ddf.reset_index()
ddf.head()
#+end_src

#+RESULTS:
:RESULTS:
|   | player_name  | DRIBBLES | SHOTS |
|---+--------------+----------+-------|
| 0 | James Harden | 0        | 240   |
| 1 | James Harden | 1        | 98    |
| 2 | James Harden | 2        | 102   |
| 3 | James Harden | 3        | 108   |
| 4 | James Harden | 4        | 87    |
:END:

**** unnormalized
#+begin_src jupyter-python :file harden-ingles-sbs.png
P = sns.catplot(x='DRIBBLES', y='SHOTS', hue='player_name', data=ddf, 
                kind='bar', legend=False, aspect=2)

fig, ax = P.fig, P.ax # if you want to work like in pyplot
ax.set_title("Number of shots taken after a given number of dribbles")
ax.legend(loc="upper right")
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.legend.Legend at 0x7f3d7fc90690>
[[file:harden-ingles-sbs.png]]
:END:

**** normalized
 I think I could have done this with a matplotlib bar plot.
#+begin_src jupyter-python :file harden-ingles-sbs-normalized.png
totals = ddf.groupby("player_name").SHOTS.sum() # 2 by 1
totals = ddf.player_name.apply(lambda n: totals[n]) # with repetitions to match ddf.SHOTS
nrmd = ddf.assign(SHOTS=lambda df: df.SHOTS/totals)

P = sns.catplot(x = 'DRIBBLES' , y='SHOTS', hue = 'player_name', data=nrmd, 
		kind='bar', legend=False, aspect=2)

fig, ax = P.fig, P.ax # if you want to work like in pyplot
ax.set_title("Percentage of shots taken after a given number of dribbles")
ax.legend(loc="upper right")

# import matplotlib.ticker as mtick
# ax.yaxis.set_major_formatter(mtick.PercentFormatter())
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.legend.Legend at 0x7f3d7aa73c10>
[[file:harden-ingles-sbs-normalized.png]]
:END:

* Clustering James Harden's shots
** first thoughts
#+begin_src jupyter-python
df.columns
#+end_src

#+RESULTS:
: Index(['GAME_ID', 'MATCHUP', 'LOCATION', 'W', 'FINAL_MARGIN', 'SHOT_NUMBER',
:        'PERIOD', 'GAME_CLOCK', 'SHOT_CLOCK', 'DRIBBLES', 'TOUCH_TIME',
:        'SHOT_DIST', 'PTS_TYPE', 'SHOT_RESULT', 'CLOSEST_DEFENDER',
:        'CLOSEST_DEFENDER_PLAYER_ID', 'CLOSE_DEF_DIST', 'FGM', 'PTS',
:        'player_name', 'player_id'],
:       dtype='object')


shot clock, dribbles, touch_time, (make percentage 2's/3's?)
** build data frames
Will want to fill NaN's for in shot clock column. Some of these are
not actually missing values--the clock was turned off, so I can just
use the game clock. But the game clock time is written in N:NN format,
so I need to convert. However, for some game 21400667 we do have eight
missing values. That's a lot, so we'll drop that game. 

#+begin_src jupyter-python :results none
jh = df[df.player_name=="James Harden"]
jh = jh.drop(index=jh[jh.GAME_ID==21400667].index)
# will fill nan's with s the converted game clock values:
s = jh.GAME_CLOCK.str.slice(start=-2).astype(float)
jh.SHOT_CLOCK = jh.SHOT_CLOCK.fillna(s)
#+end_src


There is also one weird value ewith negative touch time

#+begin_src jupyter-python
jh = jh.drop(index = jh[jh.TOUCH_TIME < 0].index)
#+end_src 

#+RESULTS:

Will compute conditional probability of belonging to this or that cluster in win vs loss.
Could also try to do some time series with cluster to show how shot selection varies.

#+begin_src jupyter-python
jhw = jh[jh.W=="W"]
jhl = jh[jh.W=="L"]
wins = jhw.GAME_ID.unique()
losses = jhl.GAME_ID.unique()
all_games = np.concatenate([wins, losses])
print("wins:")
print(wins)
print("losses:")
print(losses)
#+end_src

#+RESULTS:
: wins:
: [21400883 21400863 21400846 21400832 21400819 21400784 21400753 21400735
:  21400698 21400685 21400650 21400617 21400584 21400564 21400555 21400536
:  21400523 21400497 21400478 21400436 21400411 21400378 21400346 21400327
:  21400290 21400283 21400268 21400240 21400217 21400202 21400188 21400144
:  21400127 21400069 21400050 21400043 21400034 21400012 21400003]
: losses:
: [21400901 21400810 21400799 21400771 21400709 21400636 21400603 21400575
:  21400512 21400488 21400463 21400454 21400396 21400380 21400324 21400228
:  21400169 21400151 21400087]


#+begin_src jupyter-python :results none
cluster_vars = ["SHOT_CLOCK", "DRIBBLES", "TOUCH_TIME", "SHOT_DIST"]
jhw = jhw[cluster_vars]
jhl = jhl[cluster_vars]
#+end_src

#+begin_src jupyter-python
game_dfs = map(lambda id: jh[jh.GAME_ID == id], all_games)
jh_dict = dict(zip(all_games, game_dfs))
#+end_src

#+RESULTS:

** correlations
Comparing plots below, see see that, in losses, there is a slight
anti-correlation between shot distance and touch time. This seems to
indicate that Harden shoots more rushed threes in those games. What
does that mean? Maybe he is guarded more effectively at the
perimter. Maybe his teammates are guarded more effectively, and they
trust Harden's three, so they give the ball up to him when they're in
trouble at the end of the clock.
#+begin_src jupyter-python :file wcors.png
sns.heatmap(jhw.corr(), cmap="YlGnBu")
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.axes._subplots.AxesSubplot at 0x7f3d7a551d50>
[[file:wcors.png]]
:END:

#+begin_src jupyter-python :file lcors.png
sns.heatmap(jhl.corr(), cmap="YlGnBu")
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.axes._subplots.AxesSubplot at 0x7f3d7a485710>
[[file:lcors.png]]
:END:
** Initial plotting 

*** set up seaborn
#+begin_src jupyter-python :results none
sns.set(context="notebook",
  rc={"font.size":12, "font.family":"sans-serif", 
      "font.serif":"P052", # note: kills the original list font.serif
      "axes.titlesize":"large", "axes.titlepad":20, 
      "axes.titleweight":"bold",
      "axes.labelsize":"medium", "axes.labelpad":10, 
      "axes.labelweight":"light",  # lighter is not actually an option
      "xtick.labelsize":"small", "ytick.labelsize":"small", 
#      "axes.facecolor":"white", # vertical axis padding is werid with this
      "legend.fontsize": "medium",
      "xtick.major.width":3, "ytick.major.width":3,
      "legend.loc":"best",
      "figure.dpi":80
  }
)

context: "notebook"
#+end_src

*** look at projections
**** by hand
#+begin_src jupyter-python :results none
import itertools
pairs = itertools.combinations(jhw.columns, 2)
pairs = list(map(list, pairs))
pair = pairs[5]
#+end_src


#+begin_src jupyter-python :file scratch-w.png
jhw2 = jhw[pair]
jhw2.plot(x=pair[0], y=pair[1], kind="scatter", title="Harden in wins")
#+end_src

#+RESULTS:
:RESULTS:
: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* & *y*.  Please use the *color* keyword-argument or provide a 2-D array with a single row if you intend to specify the same RGB or RGBA value for all points.
: <matplotlib.axes._subplots.AxesSubplot at 0x7f3d7a3daf90>
[[file:scratch-w.png]]
:END:


#+begin_src jupyter-python :file scratch-l.png
jhl2 = jhl[pair]
jhl2.plot(x=pair[0], y=pair[1], kind="scatter", title="Harden in losses")
#+end_src

#+RESULTS:
:RESULTS:
: 'c' argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with 'x' & 'y'.  Please use a 2-D array with a single row if you really want to specify the same RGB or RGBA value for all points.
: <matplotlib.axes._subplots.AxesSubplot at 0x7fb1174c9350>
[[file:scratch-l.png]]
:END:

**** better
Seaborn pair grids

One win
#+begin_src jupyter-python :file scratch-w.png
g = sns.PairGrid(jh_dict[wins[0]][cluster_vars])
g.map(plt.scatter)
plt.subplots_adjust(top=0.9)
g.fig.suptitle("James Harden in wins")
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 0.98, 'James Harden in wins')
[[file:scratch-w.png]]
:END:

All at once
#+begin_src jupyter-python :file scratch-all.png
g = sns.PairGrid(jh[["W"]+cluster_vars], hue="W")
g = g.add_legend()
g.map(plt.scatter)
plt.subplots_adjust(top=0.9)
g.fig.suptitle("James Harden's shots")
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 0.98, "James Harden's shots")
[[file:scratch-all.png]]
:END:

#+begin_src jupyter-python :file scratch-w.png
g = sns.PairGrid(jhw)
g.map(plt.scatter)
plt.subplots_adjust(top=0.9)
g.fig.suptitle("James Harden's shots in wins")
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 0.98, "James Harden's shots in wins")
[[file:scratch-w.png]]
:END:

#+begin_src jupyter-python :file scratch-l.png
g = sns.PairGrid(jhl[cluster_vars])
g.map(plt.scatter)
plt.subplots_adjust(top=0.9)
g.fig.suptitle("James Harden's shots in losses")
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 0.98, "James Harden's shots in losses")
[[file:scratch-l.png]]
:END:

* Notes
** Ideas
- Cluster shots on made/miss

- How to know if there is a statistical difference between wins/losses.

- Which players have gaussian shooting patterns?

- shot_clock -- who would rush a shot

- vs good closest_defender

- put in warnings for small samples--e.g., for constructing binomial confidence interval,
should follow guidelines as in https://stats.stackexchange.com/questions/4756/confidence-interval-for-bernoulli-sampling.

** Important notes on the data
- I clean the data in clustering file and note that some touch times are
negative and some shot clock values are missing.


